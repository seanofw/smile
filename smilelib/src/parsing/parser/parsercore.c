//---------------------------------------------------------------------------------------
//  Smile Programming Language Interpreter
//  Copyright 2004-2019 Sean Werkema
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//---------------------------------------------------------------------------------------

#include <smile/types.h>
#include <smile/smiletypes/smileobject.h>
#include <smile/smiletypes/text/smilesymbol.h>
#include <smile/parsing/parser.h>
#include <smile/parsing/internal/parserinternal.h>
#include <smile/parsing/internal/parsedecl.h>
#include <smile/parsing/internal/parsescope.h>
#include <smile/internal/staticstring.h>
#include <smile/stringbuilder.h>

//-------------------------------------------------------------------------------------------------
// Parser Construction

Parser Parser_Create(void)
{
	Parser parser = GC_MALLOC_STRUCT(struct ParserStruct);
	parser->lexer = NULL;
	parser->currentScope = NULL;
	parser->customFollowSet = NULL;
	LIST_INIT(parser->firstMessage, parser->lastMessage);
	parser->parseMessages = String_Empty;
	parser->externalVars = NULL;
	parser->numExternalVars = 0;
	parser->includeLoader = Parser_DefaultIncludeLoader;
	return parser;
}

//-------------------------------------------------------------------------------------------------
// Root of the parse, and parsing nested scopes

/// <summary>
/// Helper function:  Parse the given C string as a source file.
/// </summary>
/// <param name="parser">The parser that is doing the parsing of the source text.</param>
/// <param name="scope">The scope in which the parsing is to take place.</param>
/// <param name="text">The nul-terminated string to parse, which is assumed to come from a file named "".</param>
/// <returns>The results of the parse (if errors are generated, they will be added to the parser's message collection).</returns>
SmileObject Parser_ParseFromC(Parser parser, ParseScope scope, const char *text)
{
	return Parser_ParseString(parser, scope, String_FromC(text));
}

/// <summary>
/// Helper function:  Parse the given string as a source file.
/// </summary>
/// <param name="parser">The parser that is doing the parsing of the source text.</param>
/// <param name="scope">The scope in which the parsing is to take place.</param>
/// <param name="text">The string to parse, which is assumed to come from a file named "".</param>
/// <returns>The results of the parse (if errors are generated, they will be added to the parser's message collection).</returns>
SmileObject Parser_ParseString(Parser parser, ParseScope scope, String text)
{
	Lexer lexer;
	SmileObject result;

	lexer = Lexer_Create(text, 0, String_Length(text), String_Empty, 1, 1, False);
	lexer->symbolTable = Smile_SymbolTable;
	result = Parser_Parse(parser, lexer, scope);

	return result;
}

/// <summary>
/// Parse the input from the given lexical analyzer, consuming all tokens until it reaches EOI.
/// This is the root, core parsing function.
/// </summary>
/// <param name="parser">The parser that is doing the parsing of the source text.</param>
/// <param name="lexer">The lexical analyzer that will provide both the source tokens and their file locations.</param>
/// <param name="outerScope">The parent scope in which the parsing is to take place.</param>
/// <param name="innerScope">Optional return value: The child scope of the content from the parse.</param>
/// <returns>A List that contains the expressions generated by the parse.  If errors are generated, those errors will be
/// added to the parser's message collection, and the return object will always be the Null list.</returns>
/// <remarks>
/// program ::= . exprs_opt
/// </remarks>
SmileObject Parser_ParseWithDetails(Parser parser, Lexer lexer, ParseScope outerScope, ParseScope *innerScope)
{
	ParseScope parentScope;
	Lexer oldLexer;
	SmileObject result;
	SmileList lastMessage;

	parentScope = parser->currentScope;
	oldLexer = parser->lexer;
	lastMessage = parser->lastMessage;
	
	parser->currentScope = outerScope;
	parser->lexer = lexer;

	result = Parser_ParseScopeBody(parser, innerScope);

	parser->currentScope = parentScope;
	parser->lexer = oldLexer;

	parser->parseMessages = (
		parser->lastMessage != lastMessage ? Parser_JoinMessages(
			SMILE_KIND(lastMessage) == SMILE_KIND_LIST ? lastMessage : parser->firstMessage,
			parser->lastMessage
		)
		: String_Empty
	);

	return result;
}

/// <summary>
/// Join all of the messages in the provided list, starting at 'start', up to and including 'end'.
/// </summary>
String Parser_JoinMessages(SmileList start, SmileList end)
{
	ParseMessage parseMessage;
	String str;
	DECLARE_INLINE_STRINGBUILDER(stringBuilder, 256);

	INIT_INLINE_STRINGBUILDER(stringBuilder);

	for (; SMILE_KIND(start) == SMILE_KIND_LIST; start = (SmileList)start->d) {
		if (SMILE_KIND(start->a) == SMILE_KIND_PARSEMESSAGE) {
			parseMessage = (ParseMessage)start->a;
			str = SMILE_VCALL1(parseMessage, toString, (SmileUnboxedData){ 0 });
			StringBuilder_AppendString(stringBuilder, str);
			StringBuilder_AppendByte(stringBuilder, '\n');
		}

		if (start == end)
			break;
	}

	return StringBuilder_ToString(stringBuilder);
}

/// <summary>
/// Parse the input from the given lexical analyzer as a single constant raw term.  This leaves the lexer
/// sitting at the next content after the raw term, if any.
/// </summary>
/// <param name="parser">The parser that is doing the parsing of the source text.</param>
/// <param name="lexer">The lexical analyzer that will provide both the source tokens and their file locations.</param>
/// <param name="scope">The scope in which the parsing is to take place.</param>
/// <returns>The single item resulting from the parse.  If errors are generated, those errors will be
/// added to the parser's message collection, and the return object will always be the Null list.</returns>
/// <remarks>
/// program ::= . raw_list_term
/// </remarks>
SmileObject Parser_ParseConstant(Parser parser, Lexer lexer, ParseScope scope)
{
	ParseScope parentScope;
	Lexer oldLexer;
	TemplateResult templateResult;
	SmileObject result;

	parentScope = parser->currentScope;
	oldLexer = parser->lexer;

	parser->currentScope = scope;
	parser->lexer = lexer;

	templateResult = Parser_ParseRawListTerm(parser, 0);

	if (IS_PARSE_ERROR(templateResult.parseResult)) {
		HANDLE_PARSE_ERROR(parser, templateResult.parseResult);
		result = NullObject;
	}
	else if (templateResult.templateKind != TemplateKind_None) {
		Parser_AddError(parser, Token_GetPosition(parser->lexer->token), "Template and variable data is not allowed in constant values.");
		result = NullObject;
	}
	else result = templateResult.parseResult.expr;

	parser->currentScope = parentScope;
	parser->lexer = oldLexer;

	return result;
}

//  scope ::= . LBRACE exprs_opt RBRACE
ParseResult Parser_ParseScope(Parser parser)
{
	Token endToken, startToken;
	LexerPosition startPosition;
	SmileObject body;

	STATIC_STRING(expectedOpenBraceError, "Expected { ... to begin a scope");
	STATIC_STRING(expectedCloseBraceError, "Expected ... } to end the scope starting on line %d");

	if ((startToken = Parser_NextToken(parser))->kind != TOKEN_LEFTBRACE)
		return ERROR_RESULT(ParseMessage_Create(PARSEMESSAGE_ERROR, Token_GetPosition(startToken), expectedOpenBraceError));

	startPosition = Token_GetPosition(startToken);

	body = Parser_ParseScopeBody(parser, NULL);

	if ((endToken = Parser_NextToken(parser))->kind != TOKEN_RIGHTBRACE)
		return ERROR_RESULT(ParseMessage_Create(PARSEMESSAGE_ERROR, Token_GetPosition(endToken),
			String_FormatString(expectedCloseBraceError, startPosition->line)));

	return EXPR_RESULT(body);
}

//  scope ::= LBRACE . exprs_opt RBRACE
SmileObject Parser_ParseScopeBody(Parser parser, ParseScope *bodyScope)
{
	LexerPosition startPosition;
	Int i;
	SmileList head, tail;
	SmileList declHead, declTail;
	ParseDecl *decls;
	Int numDecls;

	startPosition = Lexer_GetPosition(parser->lexer);

	Parser_BeginScope(parser, PARSESCOPE_SCOPEDECL);

	if (bodyScope != NULL)
		*bodyScope = parser->currentScope;

	LIST_INIT(head, tail);

	if (parser->numExternalVars != 0)
		Parser_ImportExternalVars(parser, &head, &tail);

	Parser_ParseExprsOpt(parser, &head, &tail, BINARYLINEBREAKS_DISALLOWED | COMMAMODE_NORMAL | COLONMODE_MEMBERACCESS);

	decls = parser->currentScope->decls;
	numDecls = parser->currentScope->numDecls;

	Parser_EndScope(parser, bodyScope != NULL);

	LIST_INIT(declHead, declTail);
	for (i = 0; i < numDecls; i++) {
		switch (decls[i]->declKind) {
			case PARSEDECL_AUTO:
				LIST_APPEND(declHead, declTail,
					SmileList_Cons((SmileObject)SmileSymbol_Create(decls[i]->symbol),
						(SmileObject)SmileList_Cons((SmileObject)SmileSymbol_Create(Smile_KnownSymbols.auto_),
							NullObject)));
				break;
			case PARSEDECL_CONST:
			case PARSEDECL_INCLUDE:
				LIST_APPEND(declHead, declTail,
					SmileList_Cons((SmileObject)SmileSymbol_Create(decls[i]->symbol),
						(SmileObject)SmileList_Cons((SmileObject)SmileSymbol_Create(Smile_KnownSymbols.set_once),
							NullObject)));
				break;
			case PARSEDECL_VARIABLE:
				LIST_APPEND(declHead, declTail, SmileSymbol_Create(decls[i]->symbol));
				break;
		}
	}

	if (SMILE_KIND(declHead) == SMILE_KIND_NULL) {
		// No declarations that require runtime scope space.
	
		if (SMILE_KIND(head) == SMILE_KIND_NULL) {
			// Empty body, so we got nothin'.
			return NullObject;
		}
		else if (head == tail) {
			// This parsed to a single expression, so no need for a [$progn] to wrap it.
			return head->a;
		}
		else {
			// Multiple expressions, so wrap a [$progn] around it.
			return (SmileObject)SmileList_ConsWithSource((SmileObject)Smile_KnownObjects._prognSymbol, (SmileObject)head, startPosition);
		}
	}
	else {
		// We have variable declarations, so we need to wrap whatever we got in a [$scope].
		return (SmileObject)SmileList_ConsWithSource((SmileObject)Smile_KnownObjects._scopeSymbol,
			(SmileObject)SmileList_ConsWithSource((SmileObject)declHead, (SmileObject)head, startPosition), startPosition);
	}
}

void Parser_ImportExternalVars(Parser parser, SmileList *head, SmileList *tail)
{
	Int i, numVars;
	ExternalVar *vars;

	if (parser->numExternalVars <= 0) return;

	vars = parser->externalVars;
	numVars = parser->numExternalVars;
	parser->externalVars = NULL;
	parser->numExternalVars = 0;

	for (i = 0; i < numVars; i++) {
		SmileObject expr = 
			(SmileObject)SmileList_Cons((SmileObject)Smile_KnownObjects._setSymbol,
				(SmileObject)SmileList_Cons((SmileObject)SmileSymbol_Create(vars[i].symbol),
					(SmileObject)SmileList_Cons(vars[i].obj,
						NullObject)));

		ParseScope_DeclareHere(parser->currentScope, vars[i].symbol, PARSEDECL_CONST, NULL, NULL);

		LIST_APPEND(*head, *tail, expr);
	}
}

//  exprs_opt ::= . exprs | .
//  exprs ::= . expr | . exprs expr
void Parser_ParseExprsOpt(Parser parser, SmileList *head, SmileList *tail, Int modeFlags)
{
	Token token;
	LexerPosition lexerPosition;
	ParseResult parseResult;

	// Consume expressions until the lookahead reaches a terminating '}' or ']' or ')'.
	while ((token = Parser_NextToken(parser))->kind != TOKEN_EOI
		&& token->kind != TOKEN_RIGHTBRACE && token->kind != TOKEN_RIGHTBRACKET && token->kind != TOKEN_RIGHTPARENTHESIS) {

		lexerPosition = Token_GetPosition(token);
		Lexer_Unget(parser->lexer);

		// Parse the next expression.
		parseResult = Parser_ParseExpr(parser, modeFlags);
		if (IS_PARSE_ERROR(parseResult)) {
			HANDLE_PARSE_ERROR(parser, parseResult);

			// Perform simple error-recovery by skipping to the next '{' '}' '[' ']' '(' ')' or '|'.
			token = Parser_Recover(parser, Parser_BracesBracketsParenthesesBar_Recovery, Parser_BracesBracketsParenthesesBar_Count);

			// Reached a terminating '}' or ']' or ')', so presume we're done consuming expressions for now.
			if (token->kind == TOKEN_RIGHTBRACE || token->kind == TOKEN_RIGHTBRACKET || token->kind == TOKEN_RIGHTPARENTHESIS)
				return;

			// Go back and try again.
			continue;
		}

		// Add the successfully-parsed expression to the output, if it's worth keeping.
		if (parseResult.status == ParseStatus_SuccessfulWithResult) {
			LIST_APPEND_WITH_SOURCE(*head, *tail, parseResult.expr, lexerPosition);
		}
	}

	Lexer_Unget(parser->lexer);
}

//  call_args_opt ::= . call_args | .
//  call_args ::= . orexpr | . call_args orexpr
void Parser_ParseCallArgsOpt(Parser parser, SmileList *head, SmileList *tail, Int modeFlags)
{
	Token token;
	LexerPosition lexerPosition;
	ParseResult parseResult;

	// Consume expressions until the lookahead reaches a terminating '}' or ']' or ')'.
	while ((token = Parser_NextToken(parser))->kind != TOKEN_EOI
		&& token->kind != TOKEN_RIGHTBRACE && token->kind != TOKEN_RIGHTBRACKET && token->kind != TOKEN_RIGHTPARENTHESIS) {

		lexerPosition = Token_GetPosition(token);
		Lexer_Unget(parser->lexer);

		// Parse the next expression.
		parseResult = Parser_ParseOrExpr(parser, modeFlags);
		if (IS_PARSE_ERROR(parseResult)) {
			HANDLE_PARSE_ERROR(parser, parseResult);

			// Perform simple error-recovery by skipping to the next '{' '}' '[' ']' '(' ')' or '|'.
			token = Parser_Recover(parser, Parser_BracesBracketsParenthesesBar_Recovery, Parser_BracesBracketsParenthesesBar_Count);

			// Reached a terminating '}' or ']' or ')', so presume we're done consuming expressions for now.
			if (token->kind == TOKEN_RIGHTBRACE || token->kind == TOKEN_RIGHTBRACKET || token->kind == TOKEN_RIGHTPARENTHESIS)
				return;

			// Go back and try again.
			continue;
		}

		// Add the successfully-parsed expression to the output, if it's worth keeping.
		if (parseResult.status == ParseStatus_SuccessfulWithResult) {
			LIST_APPEND_WITH_SOURCE(*head, *tail, parseResult.expr, lexerPosition);
		}
	}

	Lexer_Unget(parser->lexer);
}

//-------------------------------------------------------------------------------------------------
// Includes and sub-parsing

ParseResult Parser_ParseOneExpressionFromText(Parser parser, String string, LexerPosition startPosition)
{
	Lexer oldLexer;
	Token token;
	ParseResult parseResult;

	oldLexer = parser->lexer;
	parser->lexer = Lexer_Create(string, 0, String_Length(string), startPosition->filename, startPosition->line, startPosition->column, False);

	parseResult = Parser_ParseExpr(parser, BINARYLINEBREAKS_DISALLOWED | COMMAMODE_NORMAL | COLONMODE_MEMBERACCESS);
	if (IS_PARSE_ERROR(parseResult)) {
		parser->lexer = oldLexer;
		RETURN_PARSE_ERROR(parseResult);
	}

	if ((token = Parser_NextToken(parser))->kind != TOKEN_EOI) {
		parser->lexer = oldLexer;
		return ERROR_RESULT(ParseMessage_Create(PARSEMESSAGE_ERROR, Token_GetPosition(token),
			String_Format("Unexpected \"%S\" at end of dynamic string expression.", TokenKind_ToString(token->kind))));
	}

	parser->lexer = oldLexer;
	return parseResult;
}

/// <summary>
/// Read the next token from the input stream.  If the token is an identifier, correctly map
/// it to its declaration (or lack thereof) in the current scope.
/// </summary>
/// <param name="parser">The parser instance.</param>
/// <returns>The next token in the input stream.</returns>
Token Parser_NextToken(Parser parser)
{
	Token token;
	Int tokenKind;
	Symbol symbol;

	tokenKind = Lexer_Next(parser->lexer);
	token = parser->lexer->token;

	switch (tokenKind) {

		case TOKEN_ALPHANAME:
		case TOKEN_UNKNOWNALPHANAME:
			if (token->data.symbol == 0) {
				token->data.symbol = symbol = SymbolTable_GetSymbol(Smile_SymbolTable, token->text);
			}
			else {
				symbol = token->data.symbol;
			}
			token->kind = ParseScope_IsDeclared(parser->currentScope, token->data.symbol) ? TOKEN_ALPHANAME : TOKEN_UNKNOWNALPHANAME;
			break;

		case TOKEN_PUNCTNAME:
		case TOKEN_UNKNOWNPUNCTNAME:
			if (token->data.symbol == 0) {
				token->data.symbol = symbol = SymbolTable_GetSymbol(Smile_SymbolTable, token->text);
			}
			else {
				symbol = token->data.symbol;
			}
			token->kind = ParseScope_IsDeclared(parser->currentScope, token->data.symbol) ? TOKEN_PUNCTNAME : TOKEN_UNKNOWNPUNCTNAME;
			break;
	}

	return token;
}

/// <summary>
/// Read the next token from the input stream.  If the token is an identifier, correctly map
/// it to its declaration (or lack thereof) in the current scope.
/// </summary>
/// <param name="parser">The parser instance.</param>
/// <param name="parseDecl">The declaration for this token, if it is a declared token.</param>
/// <returns>The next token in the input stream.</returns>
Token Parser_NextTokenWithDeclaration(Parser parser, ParseDecl* parseDecl)
{
	Token token;
	Int tokenKind;
	Symbol symbol;
	ParseDecl decl;

	tokenKind = Lexer_Next(parser->lexer);
	token = parser->lexer->token;

	switch (tokenKind) {

		case TOKEN_ALPHANAME:
		case TOKEN_UNKNOWNALPHANAME:
			if (token->data.symbol == 0) {
				token->data.symbol = symbol = SymbolTable_GetSymbol(Smile_SymbolTable, token->text);
			}
			else {
				symbol = token->data.symbol;
			}
			decl = ParseScope_FindDeclaration(parser->currentScope, token->data.symbol);
			token->kind = decl != NULL ? TOKEN_ALPHANAME : TOKEN_UNKNOWNALPHANAME;
			*parseDecl = decl;
			break;

		case TOKEN_PUNCTNAME:
		case TOKEN_UNKNOWNPUNCTNAME:
			if (token->data.symbol == 0) {
				token->data.symbol = symbol = SymbolTable_GetSymbol(Smile_SymbolTable, token->text);
			}
			else {
				symbol = token->data.symbol;
			}
			decl = ParseScope_FindDeclaration(parser->currentScope, token->data.symbol);
			token->kind = decl != NULL ? TOKEN_PUNCTNAME : TOKEN_UNKNOWNPUNCTNAME;
			*parseDecl = decl;
			break;

		default:
			*parseDecl = NULL;
			break;
	}

	return token;
}
