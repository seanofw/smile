<?xml version="1.0" encoding="utf-8"?>
<AutoVisualizer xmlns="http://schemas.microsoft.com/vstudio/debugger/natvis/2010">

	<!-- String and StringBuilder -->
	<Type Name="StringStruct">
		<DisplayString>{(char *)_opaque.text,s}</DisplayString>
		<StringView>(char *)_opaque.text,s</StringView>
		<Expand>
			<ExpandedItem>_opaque</ExpandedItem>
		</Expand>
	</Type>
	<Type Name="StringInt">
		<DisplayString>{(char *)text,s}</DisplayString>
		<StringView>(char *)text,s</StringView>
	</Type>
	<Type Name="StringBuilderStruct">
		<DisplayString>{(char *)_opaque.text,s}</DisplayString>
		<StringView>(char *)_opaque.text,s</StringView>
		<Expand>
			<ExpandedItem>_opaque</ExpandedItem>
		</Expand>
	</Type>
	<Type Name="StringBuilderInt">
		<DisplayString>{(char *)text,s}</DisplayString>
		<StringView>(char *)text,s</StringView>
	</Type>

	<!-- Int32Dict -->
	<Type Name="Int32DictNode">
		<DisplayString Condition="key != 0 || value != 0 &amp;&amp; next &gt;= 0">key {key} --&gt; value {value}, next={next}</DisplayString>
		<DisplayString Condition="key == 0 &amp;&amp; value == 0 &amp;&amp; next &gt;= 0">next={next}</DisplayString>
		<DisplayString Condition="key != 0 || value != 0 &amp;&amp; next &lt; 0">key {key} --&gt; value {value}</DisplayString>
		<DisplayString Condition="key == 0 &amp;&amp; value == 0 &amp;&amp; next &lt; 0">null</DisplayString>
	</Type>
	<Type Name="Int32DictKeyValuePairStruct">
		<DisplayString>key {key} --&gt; value {value}</DisplayString>
	</Type>
	<Type Name="Int32DictStruct">
		<DisplayString>Int32Dict: {_opaque.count} nodes</DisplayString>
		<Expand>
			<ExpandedItem>_opaque</ExpandedItem>
		</Expand>
	</Type>
	<Type Name="Int32DictInt">
		<DisplayString>Int32Dict: {count} nodes</DisplayString>
		<Expand>
			<Item Name="[count]">count</Item>
			<Item Name="[max nodes]">mask + 1</Item>
			<Item Name="[first free]">firstFree</Item>
			<Synthetic Name="[buckets]">
				<Expand>
					<Item Name="[address]">buckets</Item>
					<IndexListItems>
						<Size>mask + 1</Size>
						<ValueNode>*(buckets[$i] >= 0 ? heap+buckets[$i] : 0)</ValueNode>
					</IndexListItems>
				</Expand>
			</Synthetic>
			<Synthetic Name="[raw buckets]">
				<Expand>
					<Item Name="[address]">buckets</Item>
					<IndexListItems>
						<Size>mask + 1</Size>
						<ValueNode>buckets[$i]</ValueNode>
					</IndexListItems>
				</Expand>
			</Synthetic>
			<Synthetic Name="[heap]">
				<Expand>
					<Item Name="[address]">heap</Item>
					<IndexListItems>
						<Size>mask + 1</Size>
						<ValueNode>heap[$i]</ValueNode>
					</IndexListItems>
				</Expand>
			</Synthetic>
		</Expand>
	</Type>

	<!-- StringDict -->
	<Type Name="StringDictNode">
		<DisplayString Condition="key != 0 || value != 0 &amp;&amp; next &gt;= 0">key {key} --&gt; value {value}, next={next}</DisplayString>
		<DisplayString Condition="key == 0 &amp;&amp; value == 0 &amp;&amp; next &gt;= 0">next={next}</DisplayString>
		<DisplayString Condition="key != 0 || value != 0 &amp;&amp; next &lt; 0">key {key} --&gt; value {value}</DisplayString>
		<DisplayString Condition="key == 0 &amp;&amp; value == 0 &amp;&amp; next &lt; 0">null</DisplayString>
	</Type>
	<Type Name="StringDictKeyValuePairStruct">
		<DisplayString>key {key} --&gt; value {value}</DisplayString>
	</Type>
	<Type Name="StringDictStruct">
		<DisplayString>StringDict: {_opaque.count} nodes</DisplayString>
		<Expand>
			<ExpandedItem>_opaque</ExpandedItem>
		</Expand>
	</Type>
	<Type Name="StringDictInt">
		<DisplayString>StringDict: {count} nodes</DisplayString>
		<Expand>
			<Item Name="[count]">count</Item>
			<Item Name="[max nodes]">mask + 1</Item>
			<Item Name="[first free]">firstFree</Item>
			<Synthetic Name="[buckets]">
				<Expand>
					<Item Name="[address]">buckets</Item>
					<IndexListItems>
						<Size>mask + 1</Size>
						<ValueNode>*(buckets[$i] >= 0 ? heap+buckets[$i] : 0)</ValueNode>
					</IndexListItems>
				</Expand>
			</Synthetic>
			<Synthetic Name="[raw buckets]">
				<Expand>
					<Item Name="[address]">buckets</Item>
					<IndexListItems>
						<Size>mask + 1</Size>
						<ValueNode>buckets[$i]</ValueNode>
					</IndexListItems>
				</Expand>
			</Synthetic>
			<Synthetic Name="[heap]">
				<Expand>
					<Item Name="[address]">heap</Item>
					<IndexListItems>
						<Size>mask + 1</Size>
						<ValueNode>heap[$i]</ValueNode>
					</IndexListItems>
				</Expand>
			</Synthetic>
		</Expand>
	</Type>

	<!-- StringIntDict -->
	<Type Name="StringIntDictNode">
		<DisplayString Condition="key != 0 || value != 0 &amp;&amp; next &gt;= 0">key {key} --&gt; value {value}, next={next}</DisplayString>
		<DisplayString Condition="key == 0 &amp;&amp; value == 0 &amp;&amp; next &gt;= 0">next={next}</DisplayString>
		<DisplayString Condition="key != 0 || value != 0 &amp;&amp; next &lt; 0">key {key} --&gt; value {value}</DisplayString>
		<DisplayString Condition="key == 0 &amp;&amp; value == 0 &amp;&amp; next &lt; 0">null</DisplayString>
	</Type>
	<Type Name="StringIntDictKeyValuePairStruct">
		<DisplayString>key {key} --&gt; value {value}</DisplayString>
	</Type>
	<Type Name="StringIntDictStruct">
		<DisplayString>StringIntDict: {_opaque.count} nodes</DisplayString>
		<Expand>
			<ExpandedItem>_opaque</ExpandedItem>
		</Expand>
	</Type>
	<Type Name="StringIntDictInt">
		<DisplayString>StringIntDict: {count} nodes</DisplayString>
		<Expand>
			<Item Name="[count]">count</Item>
			<Item Name="[max nodes]">mask + 1</Item>
			<Item Name="[first free]">firstFree</Item>
			<Synthetic Name="[buckets]">
				<Expand>
					<Item Name="[address]">buckets</Item>
					<IndexListItems>
						<Size>mask + 1</Size>
						<ValueNode>*(buckets[$i] >= 0 ? heap+buckets[$i] : 0)</ValueNode>
					</IndexListItems>
				</Expand>
			</Synthetic>
			<Synthetic Name="[raw buckets]">
				<Expand>
					<Item Name="[address]">buckets</Item>
					<IndexListItems>
						<Size>mask + 1</Size>
						<ValueNode>buckets[$i]</ValueNode>
					</IndexListItems>
				</Expand>
			</Synthetic>
			<Synthetic Name="[heap]">
				<Expand>
					<Item Name="[address]">heap</Item>
					<IndexListItems>
						<Size>mask + 1</Size>
						<ValueNode>heap[$i]</ValueNode>
					</IndexListItems>
				</Expand>
			</Synthetic>
		</Expand>
	</Type>

	<!-- SymbolTable -->
	<Type Name="SymbolTableStruct">
		<DisplayString>SymbolTable: {_opaque.count} entries</DisplayString>
		<Expand>
			<ExpandedItem>_opaque</ExpandedItem>
		</Expand>
	</Type>
	<Type Name="SymbolTableInt">
		<DisplayString>SymbolTable: {count} entries</DisplayString>
		<Expand>
			<Item Name="[count]">count</Item>
			<Item Name="[max]">max</Item>
			<Item Name="[lookup]">symbolLookup</Item>
			<IndexListItems>
				<Size>count</Size>
				<ValueNode>symbolNames[$i]</ValueNode>
			</IndexListItems>
		</Expand>
	</Type>

	<!-- SmileObject -->
	<Type Name="SmileObjectInt">

		<DisplayString Condition="(kind &amp; 0xFF) == 0x00">Byte (unboxed)</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x01">Integer16 (unboxed)</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x02">Integer32 (unboxed)</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x03">Integer64 (unboxed)</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x04">Bool (unboxed)</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x06">Float32 (unboxed)</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x07">Float64 (unboxed)</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x08">Symbol (unboxed)</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x0A">Real32 (unboxed)</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x0B">Real64 (unboxed)</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x10">Byte (boxed; value={((struct SmileByteInt *)this)->value})</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x11">Integer16 (boxed; value={((struct SmileInteger16Int *)this)->value})</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x12">Integer32 (boxed; value={((struct SmileInteger32Int *)this)->value})</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x13">Integer64 (boxed; value={((struct SmileInteger64Int *)this)->value})</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x14">Bool (boxed; {((struct SmileBoolInt *)this)-&gt;value})</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x16">Float32 (boxed)</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x17">Float64 (boxed)</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x18">Symbol (boxed; {((struct SmileSymbolInt *)this)-&gt;symbol})</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x1A">Real32 (boxed)</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x1B">Real64 (boxed)</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x20">Null</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x21">List</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x22">Primitive</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x23">Pair</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x24">UserObject</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x25">String (text={((struct SmileStringInt *)this)->string.text,s})</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x2F">Function</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0xFE">ParseDecl</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0xFF">ParseMessage (value={((struct ParseMessageStruct *)this)->message->_opaque.text,s})</DisplayString>
		<DisplayString>Undefined (kind={(char)kind &amp; 0xFF,X})</DisplayString>

		<Expand>
			<Item Name="as List" Condition="(kind &amp; 0xFF) == 0x20 || (kind &amp; 0xFF) == 0x21">(struct SmileListInt *)this</Item>
			<Item Name="as Symbol" Condition="(kind &amp; 0xFF) == 0x18">(struct SmileSymbolInt *)this</Item>
			<Item Name="as String" Condition="(kind &amp; 0xFF) == 0x25">(struct SmileStringInt *)this</Item>
			<Item Name="as Pair" Condition="(kind &amp; 0xFF) == 0x23">(struct SmilePairInt *)this</Item>
			<Item Name="as Byte" Condition="(kind &amp; 0xFF) == 0x10">(struct SmileByteInt *)this</Item>
			<Item Name="as Integer16" Condition="(kind &amp; 0xFF) == 0x11">(struct SmileInteger16Int *)this</Item>
			<Item Name="as Integer32" Condition="(kind &amp; 0xFF) == 0x12">(struct SmileInteger32Int *)this</Item>
			<Item Name="as Integer64" Condition="(kind &amp; 0xFF) == 0x13">(struct SmileInteger64Int *)this</Item>
			<Item Name="as Bool" Condition="(kind &amp; 0xFF) == 0x14">(struct SmileBoolInt *)this</Item>
			<Item Name="as UserObject" Condition="(kind &amp; 0xFF) == 0x24">(struct SmileUserObjectInt *)this</Item>
			<Item Name="as Function" Condition="(kind &amp; 0xFF) == 0x2F">(struct SmileFunctionInt *)this</Item>
			<Item Name="as ParseMessage" Condition="(kind &amp; 0xFF) == 0xFF">(struct ParseMessageStruct *)this</Item>

			<Item Name="[kind]">kind &amp; 0xFF</Item>
			<Item Name="[flags]">kind &amp; ~0xFF</Item>
			<Item Name="[vtable]">vtable</Item>
			<Item Name="[base]">base</Item>
		</Expand>
	</Type>

	<!-- SmileArg -->
	<Type Name="SmileArg">

		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x00">Byte (unboxed; value={unboxed.i8})</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x01">Integer16 (unboxed; value={unboxed.i16})</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x02">Integer32 (unboxed; value={unboxed.i32})</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x03">Integer64 (unboxed; value={unboxed.i64})</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x04">Bool (unboxed; value={unboxed.b})</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x06">Float32 (unboxed; value={unboxed.f32})</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x07">Float64 (unboxed; value={unboxed.f64})</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x08">Symbol (unboxed; value={unboxed.symbol})</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x0A">Real32 (unboxed; value={unboxed.i32})</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x0B">Real64 (unboxed; value={unboxed.i64})</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x10">Byte (boxed; value={((struct SmileByteInt *)obj)->value})</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x11">Integer16 (boxed; value={((struct SmileInteger16Int *)obj)->value})</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x12">Integer32 (boxed; value={((struct SmileInteger32Int *)obj)->value})</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x13">Integer64 (boxed; value={((struct SmileInteger64Int *)obj)->value})</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x14">Bool (boxed; {((struct SmileBoolInt *)obj)-&gt;value})</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x16">Float32 (boxed)</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x17">Float64 (boxed)</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x18">Symbol (boxed; {((struct SmileSymbolInt *)obj)-&gt;symbol})</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x1A">Real32 (boxed)</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x1B">Real64 (boxed)</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x20">Null</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x21">List</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x22">Primitive</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x23">Pair</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x24">UserObject</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x25">String (text={((struct SmileStringInt *)obj)->string.text,s})</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0x2F">Function</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0xFE">ParseDecl</DisplayString>
		<DisplayString Condition="(obj-&gt;kind &amp; 0xFF) == 0xFF">ParseMessage (value={((struct ParseMessageStruct *)obj)->message->_opaque.text,s})</DisplayString>
		<DisplayString>Undefined (kind={(char)kind &amp; 0xFF,X})</DisplayString>

		<Expand>
			<Item Name="as List" Condition="(obj-&gt;kind &amp; 0xFF) == 0x20 || (obj-&gt;kind &amp; 0xFF) == 0x21">(struct SmileListInt *)obj</Item>
			<Item Name="as Symbol" Condition="(obj-&gt;kind &amp; 0xFF) == 0x18">(struct SmileSymbolInt *)obj</Item>
			<Item Name="as String" Condition="(obj-&gt;kind &amp; 0xFF) == 0x25">(struct SmileStringInt *)obj</Item>
			<Item Name="as Pair" Condition="(obj-&gt;kind &amp; 0xFF) == 0x23">(struct SmilePairInt *)obj</Item>
			<Item Name="as Byte" Condition="(obj-&gt;kind &amp; 0xFF) == 0x10">(struct SmileByteInt *)obj</Item>
			<Item Name="as Integer16" Condition="(obj-&gt;kind &amp; 0xFF) == 0x11">(struct SmileInteger16Int *)obj</Item>
			<Item Name="as Integer32" Condition="(obj-&gt;kind &amp; 0xFF) == 0x12">(struct SmileInteger32Int *)obj</Item>
			<Item Name="as Integer64" Condition="(obj-&gt;kind &amp; 0xFF) == 0x13">(struct SmileInteger64Int *)obj</Item>
			<Item Name="as Bool" Condition="(obj-&gt;kind &amp; 0xFF) == 0x14">(struct SmileBoolInt *)obj</Item>
			<Item Name="as UserObject" Condition="(obj-&gt;kind &amp; 0xFF) == 0x24">(struct SmileUserObjectInt *)obj</Item>
			<Item Name="as Function" Condition="(obj-&gt;kind &amp; 0xFF) == 0x2F">(struct SmileFunctionInt *)obj</Item>
			<Item Name="as ParseMessage" Condition="(obj-&gt;kind &amp; 0xFF) == 0xFF">(struct ParseMessageStruct *)obj</Item>

			<Item Name="[kind]">obj->kind &amp; 0xFF</Item>
			<Item Name="[flags]">obj->kind &amp; ~0xFF</Item>
			<Item Name="[vtable]">obj->vtable</Item>
			<Item Name="[base]">obj->base</Item>
		</Expand>
	</Type>

	<!-- SmileString -->
	<Type Name="SmileStringInt">
		<DisplayString>String: {string->text,s}</DisplayString>
	</Type>

	<!-- SmileSymbol -->
	<Type Name="SmileSymbolInt">
		<DisplayString>Symbol: {symbol}</DisplayString>
	</Type>

	<!-- SmileByte -->
	<Type Name="SmileByteInt">
		<DisplayString>Byte: {value}</DisplayString>
	</Type>

	<!-- SmileInteger16 -->
	<Type Name="SmileInteger16Int">
		<DisplayString>Integer16: {value}</DisplayString>
	</Type>

	<!-- SmileInteger32 -->
	<Type Name="SmileInteger32Int">
		<DisplayString>Integer32: {value}</DisplayString>
	</Type>

	<!-- SmileInteger64 -->
	<Type Name="SmileInteger64Int">
		<DisplayString>Integer64: {value}</DisplayString>
	</Type>

	<!-- ParseMessage -->
	<Type Name="ParseMessageStruct">
		<DisplayString Condition="kind == 0">Info: line {position-&gt;line}: {message->_opaque.text,s}</DisplayString>
		<DisplayString Condition="kind == 1">Warning: line {position-&gt;line}: {message->_opaque.text,s}</DisplayString>
		<DisplayString Condition="kind == 2">Error: line {position-&gt;line}: {message->_opaque.text,s}</DisplayString>
		<DisplayString Condition="kind == 3">Fatal: line {position-&gt;line}: {message->_opaque.text,s}</DisplayString>
		<DisplayString>ParseMessage: line {position-&gt;line}: {message->_opaque.text,s}</DisplayString>
	</Type>

	<!-- LexerPosition -->
	<Type Name="LexerPositionStruct">
		<DisplayString>LexerPosition: {filename->_opaque.text, s}: line {line}, column {column}; lineStart={lineStart}, length={length} </DisplayString>
	</Type>

	<!-- SmileList -->
	<Type Name="SmileListInt">
		<DisplayString Condition="(kind &amp; 0xFF) == 0x21">List</DisplayString>
		<DisplayString Condition="(kind &amp; 0xFF) == 0x20">Null</DisplayString>
		<DisplayString>Undefined (kind={(char)kind &amp; 0xFF,X})</DisplayString>
		<Expand>
			<Item Name="[a]" Condition="(a-&gt;kind &amp; 0xFF) != 0x20 &amp;&amp; (a-&gt;kind &amp; 0xFF) != 0x21 &amp;&amp; (a-&gt;kind &amp; 0xFF) != 0x23">a</Item>
			<Item Name="[d]" Condition="(d-&gt;kind &amp; 0xFF) != 0x20 &amp;&amp; (d-&gt;kind &amp; 0xFF) != 0x21 &amp;&amp; (d-&gt;kind &amp; 0xFF) != 0x23">d</Item>
			<Item Name="[a]" Condition="(a-&gt;kind &amp; 0xFF) == 0x23">(struct SmilePairInt *)a</Item>
			<Item Name="[d]" Condition="(d-&gt;kind &amp; 0xFF) == 0x23">(struct SmilePairInt *)d</Item>
			<Item Name="[a]" Condition="(a-&gt;kind &amp; 0xFF) == 0x20 || (a-&gt;kind &amp; 0xFF) == 0x21">(struct SmileListInt *)a</Item>
			<Item Name="[d]" Condition="(d-&gt;kind &amp; 0xFF) == 0x20 || (d-&gt;kind &amp; 0xFF) == 0x21">(struct SmileListInt *)d</Item>

			<Item Name="[flags]">kind &amp; ~0xFF</Item>
			<Item Name="[vtable]">vtable</Item>
			<Item Name="[base]">base</Item>

			<LinkedListItems>
				<HeadPointer>this</HeadPointer>
				<NextPointer>(d-&gt;kind &amp; 0xFF) == 0x21 ? (struct SmileListInt *)d : 0</NextPointer>
				<ValueNode>a</ValueNode>
			</LinkedListItems>
		</Expand>
	</Type>

	<!-- SmilePair -->
	<Type Name="SmilePairInt">
		<DisplayString>Pair ({left-&gt;kind},{right-&gt;kind})</DisplayString>
		<Expand>
			<Item Name="[a]" Condition="(left-&gt;kind &amp; 0xFF) != 0x20 &amp;&amp; (left-&gt;kind &amp; 0xFF) != 0x21 &amp;&amp; (left-&gt;kind &amp; 0xFF) != 0x23">a</Item>
			<Item Name="[d]" Condition="(right-&gt;kind &amp; 0xFF) != 0x20 &amp;&amp; (right-&gt;kind &amp; 0xFF) != 0x21 &amp;&amp; (right-&gt;kind &amp; 0xFF) != 0x23">d</Item>
			<Item Name="[a]" Condition="(left-&gt;kind &amp; 0xFF) == 0x23">(struct SmilePairInt *)a</Item>
			<Item Name="[d]" Condition="(right-&gt;kind &amp; 0xFF) == 0x23">(struct SmilePairInt *)d</Item>
			<Item Name="[a]" Condition="(left-&gt;kind &amp; 0xFF) == 0x20 || (left-&gt;kind &amp; 0xFF) == 0x21">(struct SmileListInt *)a</Item>
			<Item Name="[d]" Condition="(right-&gt;kind &amp; 0xFF) == 0x20 || (right-&gt;kind &amp; 0xFF) == 0x21">(struct SmileListInt *)d</Item>

			<Item Name="[flags]">kind &amp; ~0xFF</Item>
			<Item Name="[vtable]">vtable</Item>
			<Item Name="[base]">base</Item>
		</Expand>
	</Type>

</AutoVisualizer>

